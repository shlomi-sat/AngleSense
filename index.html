<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Responsive meta tag for mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orientation Comparison Simulator</title>
  <!-- Load Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Base styling */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      font-size: 16px;
      line-height: 1.5;
    }
    
    /* Responsive container for explanation and summary areas */
    #scenarioExplanation,
    #algorithmExplanation,
    #summaryTableContainer {
      background-color: #f2f2f2;
      padding: 10px;
      margin-top: 20px;
      border: 1px solid #ddd;
      max-width: 820px;
      width: 100%;
      box-sizing: border-box;
    }
    
    /* Chart container styling */
    .chart-container {
      margin-top: 30px;
      padding: 10px;
      box-sizing: border-box;
      max-width: 820px;
      width: 100%;
    }
    
    canvas {
      width: 100% !important;
      height: auto !important;
    }
    
    /* Styling for scenario selection area */
    .scenario-select-container {
      max-width: 820px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 20px;
    }
    .scenario-select-container label,
    .scenario-select-container select,
    .scenario-select-container button {
      font-size: 18px;
    }
    
    /* Media query for smaller screens */
    @media (max-width: 600px) {
      body {
        margin: 10px;
        font-size: 16px;
      }
      .scenario-select-container label,
      .scenario-select-container select,
      .scenario-select-container button {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>Orientation Comparison Simulator</h1>
  
  <!-- Scenario Selection (the explanation of the scenario is shown separately) -->
  <div class="scenario-select-container">
    <label for="scenarioSelect">Select Scenario:</label>
    <select id="scenarioSelect">
      <option value="1">Straight and Level Flight</option>
      <option value="2">Take-off</option>
      <option value="3">Climb</option>
      <option value="4">Left Turn</option>
      <option value="5">Right Turn</option>
      <option value="6">Banked Turn</option>
      <option value="7">Turbulence</option>
      <option value="8">Wind Shear</option>
      <option value="9">Complex Maneuver</option>
      <option value="10">Emergency Maneuver</option>
      <option value="11">Rapid Acceleration Maneuver</option>
      <option value="12">Gradual Acceleration Maneuver</option>
      <option value="13">Acceleration-Deceleration Maneuver</option>
      <option value="14">Oscillatory Acceleration Maneuver</option>
      <option value="15">Variable Acceleration Maneuver</option>
    </select>
    <button id="runButton">Run Simulation</button>
  </div>
  
  <!-- Scenario Explanation (displayed in a dedicated window) -->
  <div id="scenarioExplanation"></div>
  
  <!-- Pitch Chart -->
  <div class="chart-container">
    <h2>Pitch Comparison</h2>
    <canvas id="chartPitch"></canvas>
  </div>
  
  <!-- Roll Chart -->
  <div class="chart-container">
    <h2>Roll Comparison</h2>
    <canvas id="chartRoll"></canvas>
  </div>
  
  <!-- Summary Table -->
  <div id="summaryTableContainer"></div>
  
  <!-- Algorithm Explanations -->
  <div id="algorithmExplanation"></div>
  
  <script>
    /***************** Scenarios Definition *****************/
    const scenarios = {
      "1": {
        name: "Straight and Level Flight",
        explanation: "The aircraft maintains constant altitude and heading. Pitch remains at 0° and roll at 0° throughout the 10-minute simulation.",
        simulation: function(t) { return { pitch: 0, roll: 0 }; },
        noiseFactors: { pitchAlg1: 0.1, pitchAlg2: 0.12, pitchAlg3: 0.08, pitchAlg4: 0.05,
                         rollAlg1: 0.1, rollAlg2: 0.12, rollAlg3: 0.08, rollAlg4: 0.05 }
      },
      "2": {
        name: "Take-off",
        explanation: "Pitch increases linearly from 0° to 10° over the first 120 seconds (approx. 0.0833°/sec²) while roll remains 0°.",
        simulation: function(t) { 
          let pitch = t < 120 ? 10 * (t / 120) : 10;
          return { pitch: pitch, roll: 0 }; 
        },
        noiseFactors: { pitchAlg1: 0.2, pitchAlg2: 0.25, pitchAlg3: 0.18, pitchAlg4: 0.1,
                         rollAlg1: 0.1, rollAlg2: 0.12, rollAlg3: 0.1, rollAlg4: 0.05 }
      },
      "3": {
        name: "Climb",
        explanation: "The aircraft climbs at a constant pitch of 5° with roll remaining 0°.",
        simulation: function(t) { return { pitch: 5, roll: 0 }; },
        noiseFactors: { pitchAlg1: 0.15, pitchAlg2: 0.18, pitchAlg3: 0.14, pitchAlg4: 0.1,
                         rollAlg1: 0.1, rollAlg2: 0.12, rollAlg3: 0.1, rollAlg4: 0.05 }
      },
      "4": {
        name: "Left Turn",
        explanation: "Between 200 and 400 sec, roll changes smoothly from 0° to -30° and back to 0°; pitch remains 0°. For instance, at t = 300 sec, roll ≈ -30°.",
        simulation: function(t) { 
          let roll = 0;
          if (t >= 200 && t <= 400) {
            let phase = (t - 200) / 200;
            roll = -30 * Math.sin(Math.PI * phase);
          }
          return { pitch: 0, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.1, pitchAlg2: 0.12, pitchAlg3: 0.11, pitchAlg4: 0.08,
                         rollAlg1: 0.2, rollAlg2: 0.25, rollAlg3: 0.18, rollAlg4: 0.1 }
      },
      "5": {
        name: "Right Turn",
        explanation: "Between 200 and 400 sec, roll increases smoothly from 0° to +30° and then returns to 0°; pitch remains 0°.",
        simulation: function(t) { 
          let roll = 0;
          if (t >= 200 && t <= 400) {
            let phase = (t - 200) / 200;
            roll = 30 * Math.sin(Math.PI * phase);
          }
          return { pitch: 0, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.1, pitchAlg2: 0.12, pitchAlg3: 0.11, pitchAlg4: 0.08,
                         rollAlg1: 0.2, rollAlg2: 0.25, rollAlg3: 0.18, rollAlg4: 0.1 }
      },
      "6": {
        name: "Banked Turn",
        explanation: "The aircraft maintains a constant roll of 20° and a constant pitch of 5°, simulating a coordinated turn.",
        simulation: function(t) { return { pitch: 5, roll: 20 }; },
        noiseFactors: { pitchAlg1: 0.15, pitchAlg2: 0.18, pitchAlg3: 0.14, pitchAlg4: 0.1,
                         rollAlg1: 0.15, rollAlg2: 0.18, rollAlg3: 0.14, rollAlg4: 0.1 }
      },
      "7": {
        name: "Turbulence",
        explanation: "High-frequency oscillations with ±2° amplitude and a 10 sec period affect both pitch and roll.",
        simulation: function(t) { 
          return { pitch: 2 * Math.sin(2 * Math.PI * t / 10), roll: 2 * Math.cos(2 * Math.PI * t / 10) }; 
        },
        noiseFactors: { pitchAlg1: 0.3, pitchAlg2: 0.35, pitchAlg3: 0.28, pitchAlg4: 0.15,
                         rollAlg1: 0.3, rollAlg2: 0.35, rollAlg3: 0.28, rollAlg4: 0.15 }
      },
      "8": {
        name: "Wind Shear",
        explanation: "Around 300 sec, pitch ramps to 5° in 10 sec then returns to 0°; roll remains 0°.",
        simulation: function(t) { 
          let pitch = 0;
          if(t >= 290 && t <= 310) {
            pitch = t <= 300 ? 5 * ((t - 290) / 10) : 5 * ((310 - t) / 10);
          }
          return { pitch: pitch, roll: 0 };
        },
        noiseFactors: { pitchAlg1: 0.2, pitchAlg2: 0.25, pitchAlg3: 0.18, pitchAlg4: 0.1,
                         rollAlg1: 0.1, rollAlg2: 0.12, rollAlg3: 0.1, rollAlg4: 0.05 }
      },
      "9": {
        name: "Complex Maneuver",
        explanation: "Phases: 0–150 sec: straight flight; 150–250 sec: take-off (pitch up to 10°); 250–350 sec: level flight with left bank reaching -20° roll; 350–450 sec: transition from left to right turn (pitch from 10° to 0° and roll from -20° to +20°); 450–600 sec: straight flight.",
        simulation: function(t) {
          let pitch = 0, roll = 0;
          if(t < 150) { pitch = 0; roll = 0; }
          else if(t < 250) { pitch = 10 * ((t - 150) / 100); roll = 0; }
          else if(t < 350) { pitch = 10; roll = -20; }
          else if(t < 450) { let phase = (t - 350) / 100; pitch = 10 - 10 * phase; roll = -20 + 40 * phase; }
          return { pitch: pitch, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.25, pitchAlg2: 0.3, pitchAlg3: 0.23, pitchAlg4: 0.12,
                         rollAlg1: 0.25, rollAlg2: 0.3, rollAlg3: 0.23, rollAlg4: 0.12 }
      },
      "10": {
        name: "Emergency Maneuver",
        explanation: "Between 290 and 310 sec, a rapid maneuver causes pitch to spike up to 15° and roll to oscillate with an amplitude of 10°. For example, at t = 300 sec, pitch is near 15° and roll ≈ 10°.",
        simulation: function(t) {
          let pitch = 0, roll = 0;
          if(t >= 290 && t <= 310) {
            let delta = t - 300;
            pitch = 15 * Math.exp(-Math.pow(delta,2) / 20);
            roll = 10 * Math.sin(2 * Math.PI * (t - 290) / 20);
          }
          return { pitch: pitch, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.35, pitchAlg2: 0.4, pitchAlg3: 0.33, pitchAlg4: 0.2,
                         rollAlg1: 0.35, rollAlg2: 0.4, rollAlg3: 0.33, rollAlg4: 0.2 }
      },
      "11": {
        name: "Rapid Acceleration Maneuver",
        explanation: "For t < 100 sec, pitch = 0.001·t² (e.g., at t=50 sec, pitch≈2.5°; at t=100 sec, pitch=10°), then constant at 10°. Roll remains 0°. Instantaneous pitch acceleration is 0.002·t (≈0.2°/sec at t=100).",
        simulation: function(t) {
          let pitch = (t < 100) ? 0.001 * t * t : 10;
          return { pitch: pitch, roll: 0 };
        },
        noiseFactors: { pitchAlg1: 0.15, pitchAlg2: 0.17, pitchAlg3: 0.14, pitchAlg4: 0.1,
                         rollAlg1: 0.1, rollAlg2: 0.12, rollAlg3: 0.1, rollAlg4: 0.05 }
      },
      "12": {
        name: "Gradual Acceleration Maneuver",
        explanation: "For t < 200 sec, pitch = 0.0005·t² (e.g., at t=100 sec, pitch≈5°; at t=200 sec, pitch=20°), then constant at 20°. Roll remains 0°. Instantaneous pitch acceleration is 0.001·t (≈0.2°/sec at t=200).",
        simulation: function(t) {
          let pitch = (t < 200) ? 0.0005 * t * t : 20;
          return { pitch: pitch, roll: 0 };
        },
        noiseFactors: { pitchAlg1: 0.12, pitchAlg2: 0.14, pitchAlg3: 0.11, pitchAlg4: 0.08,
                         rollAlg1: 0.1, rollAlg2: 0.12, rollAlg3: 0.1, rollAlg4: 0.05 }
      },
      "13": {
        name: "Acceleration-Deceleration Maneuver",
        explanation: "Pitch follows 10·sin(π·t/600), reaching 10° at t = 300 sec and 0° at t = 0 and 600 sec; roll follows 5·sin(π·t/600).",
        simulation: function(t) {
          let pitch = 10 * Math.sin(Math.PI * t / 600);
          let roll  = 5 * Math.sin(Math.PI * t / 600);
          return { pitch: pitch, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.15, pitchAlg2: 0.17, pitchAlg3: 0.14, pitchAlg4: 0.1,
                         rollAlg1: 0.15, rollAlg2: 0.17, rollAlg3: 0.14, rollAlg4: 0.1 }
      },
      "14": {
        name: "Oscillatory Acceleration Maneuver",
        explanation: "Pitch = (t/600)*5·sin(2πt/30), so the oscillation amplitude increases linearly (e.g., at t = 300 sec, factor = 0.5, max amplitude ≈2.5°). Roll is computed similarly.",
        simulation: function(t) {
          let factor = t / 600;
          let pitch = factor * 5 * Math.sin(2 * Math.PI * t / 30);
          let roll  = factor * 5 * Math.cos(2 * Math.PI * t / 30);
          return { pitch: pitch, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.2, pitchAlg2: 0.22, pitchAlg3: 0.18, pitchAlg4: 0.12,
                         rollAlg1: 0.2, rollAlg2: 0.22, rollAlg3: 0.18, rollAlg4: 0.12 }
      },
      "15": {
        name: "Variable Acceleration Maneuver",
        explanation: "Pitch = 5·sin(2πt/100) + 2·sin(2πt/30) and Roll = 3·cos(2πt/120) + 1.5·cos(2πt/40), combining low and high frequency components.",
        simulation: function(t) {
          let pitch = 5 * Math.sin(2 * Math.PI * t / 100) + 2 * Math.sin(2 * Math.PI * t / 30);
          let roll  = 3 * Math.cos(2 * Math.PI * t / 120) + 1.5 * Math.cos(2 * Math.PI * t / 40);
          return { pitch: pitch, roll: roll };
        },
        noiseFactors: { pitchAlg1: 0.25, pitchAlg2: 0.27, pitchAlg3: 0.23, pitchAlg4: 0.15,
                         rollAlg1: 0.25, rollAlg2: 0.27, rollAlg3: 0.23, rollAlg4: 0.15 }
      }
    };

    /***************** Update Scenario Explanation Display *****************/
    function updateScenarioExplanation() {
      const scenarioId = document.getElementById('scenarioSelect').value;
      const explanationDiv = document.getElementById('scenarioExplanation');
      explanationDiv.innerHTML = '<h3>Scenario Explanation</h3>' +
        '<p><strong>' + scenarios[scenarioId].name + '</strong>: ' + scenarios[scenarioId].explanation + '</p>';
    }
    document.getElementById('scenarioSelect').addEventListener('change', updateScenarioExplanation);
    updateScenarioExplanation();

    /***************** Run Simulation *****************/
    function runSimulation() {
      const scenarioId = document.getElementById('scenarioSelect').value;
      const scenario = scenarios[scenarioId];
      const dataPoints = 600; // 10 minutes at 1 sample/sec
      const timeLabels = [];
      const pitchTrue = [];
      const rollTrue = [];
      const pitchAlg1 = [];
      const pitchAlg2 = [];
      const pitchAlg3 = [];
      const pitchAlg4 = [];
      const rollAlg1 = [];
      const rollAlg2 = [];
      const rollAlg3 = [];
      const rollAlg4 = [];
      const noise = scenario.noiseFactors;

      // Sensor simulation constants
      const dt = 1; // time step in seconds
      const g = 9.81; // gravity (m/s²)
      const baseAccNoise = 0.2; // accelerometer noise (m/s²)
      const baseGyroNoise = 0.1; // gyroscope noise (deg/s)

      // For Algorithm 1: Basic Moving Average Filter (window size = 5)
      const windowSize = 5;
      let bufferPitch1 = [];
      let bufferRoll1 = [];
      // For Algorithm 2: Complementary Filter
      let prevEstPitch2 = null, prevEstRoll2 = null;
      const alpha = 0.98;
      // For Algorithm 3: Kalman Filter
      let estPitch3 = null, estRoll3 = null;
      let P_pitch3 = 1, P_roll3 = 1;
      const Q_val = 0.01, R_val_pitch = 0.1, R_val_roll = 0.1;
      // For Algorithm 4: Weighted Fusion Filter
      let integratedGyroPitch = 0, integratedGyroRoll = 0;
      let prevTruePitch = null, prevTrueRoll = null;

      for (let t = 0; t < dataPoints; t++) {
        timeLabels.push(t);
        const trueValues = scenario.simulation(t);
        pitchTrue.push(trueValues.pitch);
        rollTrue.push(trueValues.roll);

        // Convert true orientation to radians
        const pitchRad = trueValues.pitch * Math.PI / 180;
        const rollRad  = trueValues.roll * Math.PI / 180;

        // Simulate 3-axis accelerometer readings
        const noiseAccX = (Math.random() * 2 - 1) * baseAccNoise;
        const noiseAccY = (Math.random() * 2 - 1) * baseAccNoise;
        const noiseAccZ = (Math.random() * 2 - 1) * baseAccNoise;
        const ax = -g * Math.sin(pitchRad) + noiseAccX;
        const ay = g * Math.sin(rollRad) * Math.cos(pitchRad) + noiseAccY;
        const az = g * Math.cos(pitchRad) * Math.cos(rollRad) + noiseAccZ;
        // Compute accelerometer-based estimates
        const pitchAcc = Math.atan2(-ax, Math.sqrt(ay * ay + az * az)) * (180 / Math.PI);
        const rollAcc  = Math.atan2(ay, az) * (180 / Math.PI);

        // Simulate 3-axis gyroscope readings and integrate them
        let gyroPitch = 0, gyroRoll = 0;
        if (t === 0) {
          integratedGyroPitch = trueValues.pitch;
          integratedGyroRoll  = trueValues.roll;
          prevTruePitch = trueValues.pitch;
          prevTrueRoll = trueValues.roll;
        } else {
          gyroPitch = (trueValues.pitch - prevTruePitch) + ((Math.random() * 2 - 1) * baseGyroNoise);
          gyroRoll  = (trueValues.roll - prevTrueRoll) + ((Math.random() * 2 - 1) * baseGyroNoise);
          integratedGyroPitch += gyroPitch * dt;
          integratedGyroRoll  += gyroRoll * dt;
          prevTruePitch = trueValues.pitch;
          prevTrueRoll = trueValues.roll;
        }

        /************ Algorithm 1: Basic Moving Average Filter (BMAF) ************/
        bufferPitch1.push(pitchAcc);
        bufferRoll1.push(rollAcc);
        if (bufferPitch1.length > windowSize) {
          bufferPitch1.shift();
          bufferRoll1.shift();
        }
        const avgPitch1 = bufferPitch1.reduce((a, b) => a + b, 0) / bufferPitch1.length;
        const avgRoll1  = bufferRoll1.reduce((a, b) => a + b, 0) / bufferRoll1.length;
        const finalEstPitch1 = avgPitch1 + ((Math.random() * 2 - 1) * noise.pitchAlg1);
        const finalEstRoll1  = avgRoll1  + ((Math.random() * 2 - 1) * noise.rollAlg1);
        pitchAlg1.push(finalEstPitch1);
        rollAlg1.push(finalEstRoll1);

        /************ Algorithm 2: Complementary Filter (CF) ************/
        if (prevEstPitch2 === null) { 
          prevEstPitch2 = pitchAcc; 
          prevEstRoll2 = rollAcc; 
        }
        const compPitch = alpha * (prevEstPitch2 + gyroPitch * dt) + (1 - alpha) * pitchAcc;
        const compRoll  = alpha * (prevEstRoll2 + gyroRoll * dt) + (1 - alpha) * rollAcc;
        prevEstPitch2 = compPitch;
        prevEstRoll2 = compRoll;
        const finalEstPitch2 = compPitch + ((Math.random() * 2 - 1) * noise.pitchAlg2);
        const finalEstRoll2  = compRoll  + ((Math.random() * 2 - 1) * noise.rollAlg2);
        pitchAlg2.push(finalEstPitch2);
        rollAlg2.push(finalEstRoll2);

        /************ Algorithm 3: Kalman Filter Sensor Fusion (KFSF) ************/
        if (estPitch3 === null) { 
          estPitch3 = pitchAcc; 
          estRoll3 = rollAcc; 
        }
        const P_pred_pitch = P_pitch3 + Q_val;
        const K_pitch = P_pred_pitch / (P_pred_pitch + R_val_pitch);
        estPitch3 = estPitch3 + K_pitch * (pitchAcc - estPitch3);
        P_pitch3 = (1 - K_pitch) * P_pred_pitch;
        const P_pred_roll = P_roll3 + Q_val;
        const K_roll = P_pred_roll / (P_pred_roll + R_val_roll);
        estRoll3 = estRoll3 + K_roll * (rollAcc - estRoll3);
        P_roll3 = (1 - K_roll) * P_pred_roll;
        const finalEstPitch3 = estPitch3 + ((Math.random() * 2 - 1) * noise.pitchAlg3);
        const finalEstRoll3  = estRoll3  + ((Math.random() * 2 - 1) * noise.rollAlg3);
        pitchAlg3.push(finalEstPitch3);
        rollAlg3.push(finalEstRoll3);

        /************ Algorithm 4: Weighted Fusion Filter (WFF) ************/
        // Calculate the norm of the accelerometer vector to assess its reliability.
        const normAcc = Math.sqrt(ax * ax + ay * ay + az * az);
        // Compute weight: if normAcc is close to g, the accelerometer reading is reliable.
        const weightAcc = Math.max(0, Math.min(1, 1 - Math.abs(normAcc - g) / g));
        // Fuse the accelerometer-based estimate with the integrated gyroscope estimate.
        const fusionPitch = weightAcc * pitchAcc + (1 - weightAcc) * integratedGyroPitch;
        const fusionRoll  = weightAcc * rollAcc  + (1 - weightAcc) * integratedGyroRoll;
        const finalEstPitch4 = fusionPitch + ((Math.random() * 2 - 1) * noise.pitchAlg4);
        const finalEstRoll4  = fusionRoll  + ((Math.random() * 2 - 1) * noise.rollAlg4);
        pitchAlg4.push(finalEstPitch4);
        rollAlg4.push(finalEstRoll4);
      } // end simulation loop

      /***************** Error Calculation *****************/
      let errorPitchAlg1 = 0, errorPitchAlg2 = 0, errorPitchAlg3 = 0, errorPitchAlg4 = 0;
      let errorRollAlg1 = 0, errorRollAlg2 = 0, errorRollAlg3 = 0, errorRollAlg4 = 0;
      for (let i = 0; i < dataPoints; i++) {
        errorPitchAlg1 += Math.abs(pitchTrue[i] - pitchAlg1[i]);
        errorPitchAlg2 += Math.abs(pitchTrue[i] - pitchAlg2[i]);
        errorPitchAlg3 += Math.abs(pitchTrue[i] - pitchAlg3[i]);
        errorPitchAlg4 += Math.abs(pitchTrue[i] - pitchAlg4[i]);
        errorRollAlg1 += Math.abs(rollTrue[i] - rollAlg1[i]);
        errorRollAlg2 += Math.abs(rollTrue[i] - rollAlg2[i]);
        errorRollAlg3 += Math.abs(rollTrue[i] - rollAlg3[i]);
        errorRollAlg4 += Math.abs(rollTrue[i] - rollAlg4[i]);
      }
      const meanErrorPitchAlg1 = (errorPitchAlg1 / dataPoints).toFixed(3);
      const meanErrorPitchAlg2 = (errorPitchAlg2 / dataPoints).toFixed(3);
      const meanErrorPitchAlg3 = (errorPitchAlg3 / dataPoints).toFixed(3);
      const meanErrorPitchAlg4 = (errorPitchAlg4 / dataPoints).toFixed(3);
      const meanErrorRollAlg1 = (errorRollAlg1 / dataPoints).toFixed(3);
      const meanErrorRollAlg2 = (errorRollAlg2 / dataPoints).toFixed(3);
      const meanErrorRollAlg3 = (errorRollAlg3 / dataPoints).toFixed(3);
      const meanErrorRollAlg4 = (errorRollAlg4 / dataPoints).toFixed(3);

      /***************** Update Charts *****************/
      updateChartPitch(timeLabels, pitchTrue, pitchAlg1, pitchAlg2, pitchAlg3, pitchAlg4);
      updateChartRoll(timeLabels, rollTrue, rollAlg1, rollAlg2, rollAlg3, rollAlg4);

      /***************** Update Summary Table *****************/
      const summaryHTML = '<h3>Summary of Mean Absolute Errors</h3>' +
        '<table>' +
          '<tr>' +
            '<th>Measurement</th>' +
            '<th>Unit</th>' +
            '<th>Algorithm 1 (BMAF)</th>' +
            '<th>Algorithm 2 (Complementary Filter)</th>' +
            '<th>Algorithm 3 (Kalman Filter)</th>' +
            '<th>Algorithm 4 (Weighted Fusion)</th>' +
          '</tr>' +
          '<tr>' +
            '<td>Pitch</td>' +
            '<td>degrees</td>' +
            '<td>' + meanErrorPitchAlg1 + '</td>' +
            '<td>' + meanErrorPitchAlg2 + '</td>' +
            '<td>' + meanErrorPitchAlg3 + '</td>' +
            '<td>' + meanErrorPitchAlg4 + '</td>' +
          '</tr>' +
          '<tr>' +
            '<td>Roll</td>' +
            '<td>degrees</td>' +
            '<td>' + meanErrorRollAlg1 + '</td>' +
            '<td>' + meanErrorRollAlg2 + '</td>' +
            '<td>' + meanErrorRollAlg3 + '</td>' +
            '<td>' + meanErrorRollAlg4 + '</td>' +
          '</tr>' +
        '</table>';
      document.getElementById('summaryTableContainer').innerHTML = summaryHTML;

      /***************** Update Algorithm Explanations *****************/
      const algorithmHTML = `
        <h3>Algorithm Explanations</h3>
        <h4>Sensor Data Overview:</h4>
        <p>Each algorithm uses simulated 3-axis accelerometer and 3-axis gyroscope data. The accelerometer measures linear acceleration along the X, Y, and Z axes (ax, ay, az). Although it does not directly measure angles, we assume that gravity (≈9.81 m/s²) is the dominant acceleration. Thus, we derive an estimate for pitch as:</p>
        <pre>
pitch_acc = arctan2(-ax, sqrt(ay² + az²))   (in degrees)
roll_acc  = arctan2(ay, az)                   (in degrees)
        </pre>
        <p>The gyroscope measures angular rates (in deg/s) about each axis, which are integrated over time (Δt = 1 sec) to obtain changes in orientation.</p>
        
        <h4>Algorithm 1: Basic Moving Average Filter (BMAF)</h4>
        <ol>
          <li>Calculate pitch_acc and roll_acc from the accelerometer data.</li>
          <li>Maintain a moving window of the last 5 samples and compute their average.</li>
          <li>Add a small random noise to simulate sensor imperfections.</li>
        </ol>
        
        <h4>Algorithm 2: Complementary Filter (CF)</h4>
        <ol>
          <li>Calculate pitch_acc and roll_acc.</li>
          <li>Integrate the gyroscope readings over time to obtain gyro-based estimates.</li>
          <li>Fuse these estimates using the equation:
              <br>θ_est(t) = 0.98 · (θ_est(t–1) + gyro·Δt) + 0.02 · pitch_acc(t)
          </li>
        </ol>
        
        <h4>Algorithm 3: Kalman Filter Sensor Fusion (KFSF)</h4>
        <ol>
          <li>Prediction: Update the error covariance:
              <br>P_pred = P_previous + Q
          </li>
          <li>Update: Compute Kalman gain:
              <br>K = P_pred / (P_pred + R)
              <br>Then update the estimate:
              <br>θ_est = previous_estimate + K · (pitch_acc – previous_estimate)
              <br>and update P: P = (1 – K) · P_pred.
          </li>
          <li>This process is applied separately for pitch and roll.</li>
        </ol>
        
        <h4>Algorithm 4: Weighted Fusion Filter (WFF)</h4>
        <ol>
          <li>Calculate pitch_acc and roll_acc.</li>
          <li>Compute the norm of the accelerometer vector:
              <br>norm = sqrt(ax² + ay² + az²)
          </li>
          <li>Determine a weight:
              <br>weight = 1 – |norm – g| / g
              <br>(A weight close to 1 indicates that the accelerometer reading is reliable.)</li>
          <li>Integrate the gyroscope readings over time to obtain gyro-based estimates.</li>
          <li>Fuse the two estimates:
              <br>pitch_est = weight · pitch_acc + (1 – weight) · (integrated gyro pitch)
              <br>roll_est  = weight · roll_acc  + (1 – weight) · (integrated gyro roll)
          </li>
        </ol>
        <p>This method explicitly uses the accelerometer’s measurement of acceleration along each axis by computing its norm, which serves as an indicator of reliability.</p>
      `;
      document.getElementById('algorithmExplanation').innerHTML = algorithmHTML;
    }

    /***************** Chart Update Functions *****************/
    let chartPitch, chartRoll;
    function updateChartPitch(labels, trueData, alg1Data, alg2Data, alg3Data, alg4Data) {
      const ctx = document.getElementById('chartPitch').getContext('2d');
      if (chartPitch) { chartPitch.destroy(); }
      chartPitch = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            { label: 'Ground Truth (Pitch)', data: trueData, borderColor: 'green', fill: false },
            { label: 'Algorithm 1 (BMAF)', data: alg1Data, borderColor: 'blue', fill: false },
            { label: 'Algorithm 2 (Complementary Filter)', data: alg2Data, borderColor: 'red', fill: false },
            { label: 'Algorithm 3 (Kalman Filter)', data: alg3Data, borderColor: 'purple', fill: false },
            { label: 'Algorithm 4 (Weighted Fusion)', data: alg4Data, borderColor: 'orange', fill: false }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { position: 'top' }, title: { display: true, text: 'Pitch Comparison' } },
          scales: {
            x: { title: { display: true, text: 'Time (seconds)' } },
            y: { title: { display: true, text: 'Pitch (degrees)' } }
          }
        }
      });
    }

    function updateChartRoll(labels, trueData, alg1Data, alg2Data, alg3Data, alg4Data) {
      const ctx = document.getElementById('chartRoll').getContext('2d');
      if (chartRoll) { chartRoll.destroy(); }
      chartRoll = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            { label: 'Ground Truth (Roll)', data: trueData, borderColor: 'green', fill: false },
            { label: 'Algorithm 1 (BMAF)', data: alg1Data, borderColor: 'blue', fill: false },
            { label: 'Algorithm 2 (Complementary Filter)', data: alg2Data, borderColor: 'red', fill: false },
            { label: 'Algorithm 3 (Kalman Filter)', data: alg3Data, borderColor: 'purple', fill: false },
            { label: 'Algorithm 4 (Weighted Fusion)', data: alg4Data, borderColor: 'orange', fill: false }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { position: 'top' }, title: { display: true, text: 'Roll Comparison' } },
          scales: {
            x: { title: { display: true, text: 'Time (seconds)' } },
            y: { title: { display: true, text: 'Roll (degrees)' } }
          }
        }
      });
    }

    document.getElementById('runButton').addEventListener('click', runSimulation);
  </script>
</body>
</html>
